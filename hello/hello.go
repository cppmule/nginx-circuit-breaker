package main

import (
    "log"
    "net"
    "net/http"
    "encoding/json"
    "time"
    "strconv"
    "os"
)

type Response struct {
    Message string `json:"message"`
}

type Toggle struct {
    errorMode bool
}

func main() {
    var h = Toggle{false}

    mux := http.NewServeMux()

    mux.HandleFunc("/health", healthHandler)
    mux.HandleFunc("/", func (w http.ResponseWriter, r *http.Request) {
        if r.Method == "POST" {
            h.errorMode = !h.errorMode
            sendResponse(w, r, 0, "Toggled error mode", http.StatusOK)
        } else if h.errorMode  == true {
            sendResponse(w, r, 3000, "Something went wrong", http.StatusServiceUnavailable)
        } else {
            sendResponse(w, r, 1000, "Success", http.StatusOK)
        }
    })

    log.Fatal(http.ListenAndServe(":8000", mux))
    log.Printf("HTTP service listening on 8000")
}

func healthHandler(w http.ResponseWriter, r *http.Request) {
    sendResponse(w, r, 0, "OK", http.StatusOK)
}

func sendResponse(w http.ResponseWriter, r *http.Request, timeout int, response string, status int) {
    var logger = log.New(os.Stdout, "", 0)
    time.Sleep(time.Duration(timeout) * time.Millisecond)
    if status == http.StatusOK {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(Response{Message: response})    
    } else {
        http.Error(w, response, status)
    }

    logCombined(logger, r, status)
    logHostname()
}

func logCombined(logger *log.Logger, r *http.Request, status int) {
    t := time.Now()
    logger.Printf(r.RemoteAddr + " [" + t.Format("02/Jan/2006:15:04:05Z") + "] \"" + r.Method + " " + r.RequestURI + " " + r.Proto + "\" " + strconv.Itoa(status) + " \"" + r.Referer() + "\" " + "\"" + r.UserAgent() + "\"")
}

func logHostname() {
    var hostname, _ = os.Hostname()
    ifaces, _ := net.Interfaces()
    addrs, _ := ifaces[1].Addrs()

    log.Printf("Response generated by " + addrs[0].String() + " (" + hostname + ")")
}

